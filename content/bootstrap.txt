/* eslint-disable no-magic-numbers */

declare const dump: (msg: string) => void

const {classes: Cc, interfaces: Ci, utils: Cu} = Components
Cu.import('resource://gre/modules/Services.jsm')

const consoleService = Components.classes['@mozilla.org/consoleservice;1'].getService(Components.interfaces.nsIConsoleService)
function logMessage(msg) {
  consoleService.logStringMessage(`ODF Scan: ${msg}`)
}

/**
 * Apply a callback to each open and new browser windows.
 *
 * @usage watchWindows(callback): Apply a callback to each browser window.
 * @param [function] callback: 1-parameter function that gets a browser window.
 */
function watchWindows(callback) {
  // Travelling object used to store original attribute values
  // needed for uninstall
  let tabCallbackInfo = {}
  // Wrap the callback in a function that ignores failures
  function watcher(window) { // eslint-disable-line prefer-arrow/prefer-arrow-functions
    try {
      // Now that the window has loaded, only handle browser windows
      const {documentElement} = window.document
      if (documentElement.getAttribute('windowtype') === 'navigator:browser'
    || documentElement.getAttribute('windowtype') === 'zotero:basicViewer') {
        const menuElem = window.document.getElementById('menu_rtfScan')
        if (!menuElem) return
        const cmdElem = window.document.getElementById('cmd_zotero_rtfScan')
        const windowUtils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowUtils)
        const windowID = windowUtils.outerWindowID
        tabCallbackInfo[windowID] = {
          oldLabel:menuElem.getAttribute('label'),
          oldRtfScanCommand:cmdElem.getAttribute('oncommand'),
          children: {},
        }
        if (window.gBrowser && window.gBrowser.tabContainer) {

          const tabContainer = window.gBrowser.tabContainer

          // Tab monitor callback wrapper. Sets aside enough information
          // to shut down listeners on plugin uninstall or disable. Tabs in
          // which Zotero/MLZ are not detected are sniffed at, then ignored
          function tabSelect(_event) { // eslint-disable-line no-inner-declarations, prefer-arrow/prefer-arrow-functions
            // Capture a pointer to this tab window for use in the setTimeout,
            // and make a note of the tab windowID (needed for uninstall)
            const contentWindow = window.content

            // eslint-disable-next-line @typescript-eslint/no-shadow
            const windowUtils = contentWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowUtils)

            const contentWindowID = windowUtils.outerWindowID

            // Only once for per tab in this browser window
            if (tabCallbackInfo[windowID].children[contentWindowID]) return

            // Allow a little time for the window to start. If recognition
            // fails on tab open, a later select will still pick it up
            // eslint-disable-next-line @typescript-eslint/no-shadow
            window.setTimeout((contentWindow, tabCallbackInfo, windowID, contentWindowID, callback) => {
              // eslint-disable-next-line @typescript-eslint/no-shadow
              const menuElem = contentWindow.document.getElementById('menu_rtfScan')
              if (!menuElem) return

              // Children are Zotero tab instances and only one can exist
              for (const key of Object.keys(tabCallbackInfo[windowID].children)) {
                delete tabCallbackInfo[windowID].children[key]
              }
              tabCallbackInfo[windowID].children[contentWindowID] = true
              callback(contentWindow)
            }, 1000, contentWindow, tabCallbackInfo, windowID, contentWindowID, callback)
          }

          // Modify tabs
          // tabOpen event implies tabSelect, so this is enough
          tabContainer.addEventListener('TabSelect', tabSelect, false)

          // Function to remove listener on uninstall
          tabCallbackInfo[windowID].removeListener = () => {
            tabContainer.removeEventListener('TabSelect', tabSelect)
          }
        }

        // Modify the chrome window itself
        callback(window)
      }
    }
    catch (ex) {
      dump(`ERROR (rtf-odf-scan-for-zotero): in watcher(): ${ex}`)
    }
  }

  // Wait for the window to finish loading before running the callback
  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
  function runOnLoad(window) {
    // Listen for one load event before checking the window type
    // ODF Scan: run until we find both the main window and a tab ...
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    window.addEventListener('load', function runOnce() {
      window.removeEventListener('load', runOnce, false)
      watcher(window)
    }, false)
  }

  // Add functionality to existing windows
  const windows = Services.wm.getEnumerator(null)
  while (windows.hasMoreElements()) {
  // Only run the watcher immediately if the window is completely loaded
    const window = windows.getNext()
    if (window.document.readyState === 'complete') {
      watcher(window)
    }
    else {
      // Wait for the window to load before continuing
      runOnLoad(window)
    }
  }

  // Watch for new browser windows opening then wait for it to load
  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
  function windowWatcher(subject, topic) {
    if (topic === 'domwindowopened') runOnLoad(subject)
  }
  Services.ww.registerNotification(windowWatcher)

  // Make sure to stop watching for windows if we're unloading
  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
  unload(function() {
    Services.ww.unregisterNotification(windowWatcher)

    // DEBUG: This isn't currently called when the plugin is unloaded
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function removeMenuItem(win) {
      const menuElem = win.document.getElementById('menu_odfScan')
      menuElem.parentNode.removeChild(menuElem)
    }

    try {
      const someWindow = Services.wm.getMostRecentWindow(null)
      const windowUtils = someWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowUtils)
      for (const windowID of Object.keys(tabCallbackInfo)) {

        // Get our main window
        const win = windowUtils.getOuterWindowWithId(parseInt(windowID,10))
        if (!win) continue

        // Remove listener
        tabCallbackInfo[windowID].removeListener()

        // Remove menu item
        removeMenuItem(win)

        // Tick through the affected child tabs of this browser window
        // restoring behaviour there too
        for (const contentWindowID of Object.keys(tabCallbackInfo[windowID].children)) {

          // Get content window
          const contentWin = windowUtils.getOuterWindowWithId(parseInt(contentWindowID, 10))
          if (!contentWin) continue

          // Restore old behaviour
          removeMenuItem(contentWin)
        }
      }
    }
    catch (e) {
      dump(`ERROR (rtf-odf-scan-for-zotero): in unload(): ${e}\n`)
    }
    tabCallbackInfo = {}
  })
}


/**
 * Save callbacks to run when unloading. Optionally scope the callback to a
 * container, e.g., window. Provide a way to run all the callbacks.
 *
 * @usage unload(): Run all callbacks and release them.
 *
 * @usage unload(callback): Add a callback to run on unload.
 * @param [function] callback: 0-parameter function to call on unload.
 * @return [function]: A 0-parameter function that undoes adding the callback.
 *
 * @usage unload(callback, container) Add a scoped callback to run on unload.
 * @param [function] callback: 0-parameter function to call on unload.
 * @param [node] container: Remove the callback when this container unloads.
 * @return [function]: A 0-parameter function that undoes adding the callback.
 */
function unload(callback?: () => void, container?: any) {
  // Initialize the array of unloaders on the first usage
  const unloaders = unload.unloaders
  if (!unloaders) unloaders = unload.unloaders = []

  // Calling with no arguments runs all the unloader callbacks
  if (!callback) {
    // eslint-disable-next-line @typescript-eslint/no-shadow
    unloaders.slice().forEach(unloader => { unloader() })
    unloaders.length = 0
    return
  }

  // The callback is bound to the lifetime of the container if we have one
  if (container) {
  // Remove the unloader when the container unloads
    container.addEventListener('unload', removeUnloader, false)

    // Wrap the callback to additionally remove the unload listener
    const origCallback = callback
    callback = function() { // eslint-disable-line prefer-arrow/prefer-arrow-functions
      container.removeEventListener('unload', removeUnloader, false)
      const tabContainer = container.gBrowser.tabContainer
      tabContainer.removeEventListener('TabSelect', container.tabSelect)
      origCallback()
    }
  }

  // Wrap the callback in a function that ignores failures
  function unloader() { // eslint-disable-line prefer-arrow/prefer-arrow-functions
    try {
      callback()
    }
    catch (ex) {}
  }
  unloaders.push(unloader)

  // Provide a way to remove the unloader
  function removeUnloader() { // eslint-disable-line prefer-arrow/prefer-arrow-functions
    const index = unloaders.indexOf(unloader)
    if (index !== -1) unloaders.splice(index, 1)
  }
  return removeUnloader
}

function addMenuItem(window) {
  const menu = window.document.getElementById('menu_ToolsPopup')
  const rtfMenuElem = window.document.getElementById('menu_rtfScan')
  const odfMenuElem = window.document.createElement('menuitem')
  odfMenuElem.id = 'menu_odfScan'
  odfMenuElem.setAttribute('label', 'ODF Scan')
  odfMenuElem.setAttribute('oncommand', "window.openDialog('chrome://rtf-odf-scan-for-zotero/content/rtfScan.xul', 'odfScan', 'chrome,centerscreen')")
  menu.insertBefore(odfMenuElem, rtfMenuElem.nextSibling)
}

function installTranslator() {
  const Zotero = Cc['@zotero.org/Zotero;1'].getService(Ci.nsISupports).wrappedJSObject

  logMessage('installing ODF scan translator')
  const data = Zotero.File.getContentsFromURL('resource://rtf-odf-scan-for-zotero/translators/Scannable%20Cite.js')
  data = data.match(/^([\s\S]+?}\n\n)([\s\S]+)/)
  data = {
    header: JSON.parse(data[1]),
    code: data[2],
  }

  logMessage('popping up window')
  const pw = new Zotero.ProgressWindow()
  pw.changeHeadline('ODF Scan: waiting for Zotero...')
  pw.addDescription('Waiting for Zotero translator framework to initialize...')
  pw.show()

  Zotero.Schema.schemaUpdatePromise.then(() => {
    logMessage('Zotero ready')
    pw.startCloseTimer(500)
    Zotero.Translators.save(data.header, data.code).then(() => {
      Zotero.Translators.reinit()
      logMessage('translator installed')
    })
  }).catch(err => {
    logMessage(`translator install failed: ${err}`)
  })
}

type Plugin = {
  id: string // The ID of the add-on being bootstrapped.
  version: string // The version of the add-on being bootstrapped.
  installPath: string // actually, nsIFile, The installation location of the add-on being bootstrapped. This may be a directory or an XPI file depending on whether the add-on is installed unpacked or not.
  resourceURI: string // actually nsIURI, a URI pointing at the root of the add-ons files, this may be a jar: or file: URI depending on whether the add-on is installed unpacked or not.
  oldVersion: string // The previously installed version, if the reason is ADDON_UPGRADE or ADDON_DOWNGRADE, and the method is install or startup.
  newVersion: string // The version to be installed, if the reason is ADDON_UPGRADE or ADDON_DOWNGRADE, and the method is shutdown or uninstall.
}

enum Reason {
  APP_STARTUP     = 1, // The application is starting up.
  APP_SHUTDOWN    = 2, // The application is shutting down.
  ADDON_ENABLE    = 3, // The add-on is being enabled.
  ADDON_DISABLE   = 4, // The add-on is being disabled. (Also sent during uninstallation)
  ADDON_INSTALL   = 5, // The add-on is being installed.
  ADDON_UNINSTALL = 6, // The add-on is being uninstalled.
  ADDON_UPGRADE   = 7, // The add-on is being upgraded.
  ADDON_DOWNGRADE = 8, // The add-on is being downgraded.
}

/**
 * Handle the add-on being activated on install/enable
 */
export function startup(_data: Plugin, _reason: Reason): void {
  logMessage('startup')
  // Shift all open and new browser windows
  setDefaultPrefs()
  watchWindows(addMenuItem)
}

/**
 * Handle the add-on being deactivated on uninstall/disable
 */
export function shutdown(_data: Plugin, _reason: Reason): void {
  // Clean up with unloaders when we're deactivating
  if (reason !== Reason.APP_SHUTDOWN) unload()
}

/**
 * Handle the add-on being installed
 */
export function install(_data: Plugin, _reason: Reason): void {
  logMessage('install')
  watchWindows(installTranslator)
}

/**
 * Handle the add-on being uninstalled
 */
export function uninstall(data: Plugin, reason: Reason): void {
  logMessage(`uninstall: ${data.id} ${reason}`)
}
